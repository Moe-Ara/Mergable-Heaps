<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mergable-Heaps: FibonacciHeap Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mergable-Heaps
   </div>
   <div id="projectbrief">Effiecent Mergable Heaps</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d0/d4b/class_fibonacci_heap.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../d9/d34/class_fibonacci_heap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">FibonacciHeap Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac053cdb66516a33d1bf65a02a73dee67"><td class="memItemLeft" align="right" valign="top"><a id="ac053cdb66516a33d1bf65a02a73dee67" name="ac053cdb66516a33d1bf65a02a73dee67"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FibonacciHeap</b> ()</td></tr>
<tr class="memdesc:ac053cdb66516a33d1bf65a02a73dee67"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 Constructor to create an empty Fibonacci Heap <br /></td></tr>
<tr class="separator:ac053cdb66516a33d1bf65a02a73dee67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b1aef3e2c5b729472bc9eaa82541f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a01b1aef3e2c5b729472bc9eaa82541f9">FibonacciHeap</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *)</td></tr>
<tr class="memdesc:a01b1aef3e2c5b729472bc9eaa82541f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 Constructor to create a Fibonacci Heap with one node  <a href="../../d0/d4b/class_fibonacci_heap.html#a01b1aef3e2c5b729472bc9eaa82541f9">More...</a><br /></td></tr>
<tr class="separator:a01b1aef3e2c5b729472bc9eaa82541f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3805764e424d13b921e1938b068b1c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a3805764e424d13b921e1938b068b1c30">FibonacciHeap_Insert</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *)</td></tr>
<tr class="memdesc:a3805764e424d13b921e1938b068b1c30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 Insert Operation to insert a new node n into a Fibonacci Heap H. It has O(1) actual cost and O(1) amortized cost  <a href="../../d0/d4b/class_fibonacci_heap.html#a3805764e424d13b921e1938b068b1c30">More...</a><br /></td></tr>
<tr class="separator:a3805764e424d13b921e1938b068b1c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace10cdd22faa2ccf322c15f998e1a87c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html">FibonacciHeap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#ace10cdd22faa2ccf322c15f998e1a87c">FibonacciHeap_Union</a> (<a class="el" href="../../d0/d4b/class_fibonacci_heap.html">FibonacciHeap</a> *)</td></tr>
<tr class="separator:ace10cdd22faa2ccf322c15f998e1a87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e711c7230240cebd272eed18becfd13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a1e711c7230240cebd272eed18becfd13">FibonacciHeap_extractMin</a> ()</td></tr>
<tr class="memdesc:a1e711c7230240cebd272eed18becfd13"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 Operation used to extract the node with the highest priority (node with minimum key), the operation removes it from the Heap and returns it. It has O(D(n) + t(H)) actual cost, and O(D(n)) amortized cost which is O(lg n)  <a href="../../d0/d4b/class_fibonacci_heap.html#a1e711c7230240cebd272eed18becfd13">More...</a><br /></td></tr>
<tr class="separator:a1e711c7230240cebd272eed18becfd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3073baeb16636d2f607a88340e6f0823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a3073baeb16636d2f607a88340e6f0823">FibonacciHeap_decreaseKey</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *, int)</td></tr>
<tr class="memdesc:a3073baeb16636d2f607a88340e6f0823"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 Operation used to decrease a key k of a node x. It has O(c) actual cost, and O(1) amortized cost  <a href="../../d0/d4b/class_fibonacci_heap.html#a3073baeb16636d2f607a88340e6f0823">More...</a><br /></td></tr>
<tr class="separator:a3073baeb16636d2f607a88340e6f0823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7ed8f7289a45623bcd296c8ae5ce53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a4d7ed8f7289a45623bcd296c8ae5ce53">FibonacciHeap_delete</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *)</td></tr>
<tr class="memdesc:a4d7ed8f7289a45623bcd296c8ae5ce53"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 This operation is used to delete a node n from Heap. Its amortized cost is O(lg n)  <a href="../../d0/d4b/class_fibonacci_heap.html#a4d7ed8f7289a45623bcd296c8ae5ce53">More...</a><br /></td></tr>
<tr class="separator:a4d7ed8f7289a45623bcd296c8ae5ce53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257f38b37fa18411f8aa7f5c6f1acd48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a257f38b37fa18411f8aa7f5c6f1acd48">getnumberOfNodes</a> ()</td></tr>
<tr class="memdesc:a257f38b37fa18411f8aa7f5c6f1acd48"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 Getter to get the number of nodes n[H]  <a href="../../d0/d4b/class_fibonacci_heap.html#a257f38b37fa18411f8aa7f5c6f1acd48">More...</a><br /></td></tr>
<tr class="separator:a257f38b37fa18411f8aa7f5c6f1acd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141474ef627e68752188119c5158eb13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a141474ef627e68752188119c5158eb13">getMin</a> ()</td></tr>
<tr class="memdesc:a141474ef627e68752188119c5158eb13"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 Getter to get the node with the minimum key  <a href="../../d0/d4b/class_fibonacci_heap.html#a141474ef627e68752188119c5158eb13">More...</a><br /></td></tr>
<tr class="separator:a141474ef627e68752188119c5158eb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5083823697f227b55cc041db6a001788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a5083823697f227b55cc041db6a001788">FibonacciHeap_Link</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *, <a class="el" href="../../dc/d8f/class_node.html">Node</a> *)</td></tr>
<tr class="memdesc:a5083823697f227b55cc041db6a001788"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 This operation is used to link nodes together, it does so by removing a node y from the root list of heap H, and making it a child of a node x  <a href="../../d0/d4b/class_fibonacci_heap.html#a5083823697f227b55cc041db6a001788">More...</a><br /></td></tr>
<tr class="separator:a5083823697f227b55cc041db6a001788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e16b4de472d878d59d5beccbc84e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a15e16b4de472d878d59d5beccbc84e79">consolidate</a> ()</td></tr>
<tr class="memdesc:a15e16b4de472d878d59d5beccbc84e79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 This operation is used by extractMin(). It is used to link roots that has equal degrees until each root in the rool List of H, has a unique degree.  <a href="../../d0/d4b/class_fibonacci_heap.html#a15e16b4de472d878d59d5beccbc84e79">More...</a><br /></td></tr>
<tr class="separator:a15e16b4de472d878d59d5beccbc84e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2642da134c9235d5b4a0c5ac005c055e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a2642da134c9235d5b4a0c5ac005c055e">cut</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *, <a class="el" href="../../dc/d8f/class_node.html">Node</a> *)</td></tr>
<tr class="memdesc:a2642da134c9235d5b4a0c5ac005c055e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description </b> <br  />
 This operation is used by decreaseKey(). it is used to cut the link between node x and its parent y making x a new root in the root list  <a href="../../d0/d4b/class_fibonacci_heap.html#a2642da134c9235d5b4a0c5ac005c055e">More...</a><br /></td></tr>
<tr class="separator:a2642da134c9235d5b4a0c5ac005c055e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389dff05276dc7cd14c12838715236c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html#a389dff05276dc7cd14c12838715236c6">cascadingCut</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *)</td></tr>
<tr class="memdesc:a389dff05276dc7cd14c12838715236c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 This operation is used by decreaseKey(). It cuts y from its parent and makes it a new root, however the parent of y is the new y. It calls itself recursivly, to cut all children of node n and make them new roots. It recurses until y is a root or it finds an unmarked node  <a href="../../d0/d4b/class_fibonacci_heap.html#a389dff05276dc7cd14c12838715236c6">More...</a><br /></td></tr>
<tr class="separator:a389dff05276dc7cd14c12838715236c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5c5666b2f0390e87c7080792167b9eec"><td class="memItemLeft" align="right" valign="top"><a id="a5c5666b2f0390e87c7080792167b9eec" name="a5c5666b2f0390e87c7080792167b9eec"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfNodes</b></td></tr>
<tr class="memdesc:a5c5666b2f0390e87c7080792167b9eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of nodes in Heap H, n[H] <br /></td></tr>
<tr class="separator:a5c5666b2f0390e87c7080792167b9eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd6968ecec33c55c92161f1cea337f"><td class="memItemLeft" align="right" valign="top"><a id="a64dd6968ecec33c55c92161f1cea337f" name="a64dd6968ecec33c55c92161f1cea337f"></a>
<a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b></td></tr>
<tr class="memdesc:a64dd6968ecec33c55c92161f1cea337f"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the root in Heap H <br /></td></tr>
<tr class="separator:a64dd6968ecec33c55c92161f1cea337f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53e7b074024d6b6c9a13652f8e7329b"><td class="memItemLeft" align="right" valign="top"><a id="ad53e7b074024d6b6c9a13652f8e7329b" name="ad53e7b074024d6b6c9a13652f8e7329b"></a>
<a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>min</b></td></tr>
<tr class="memdesc:ad53e7b074024d6b6c9a13652f8e7329b"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer the <a class="el" href="../../dc/d8f/class_node.html">Node</a> with the minimum key value <br /></td></tr>
<tr class="separator:ad53e7b074024d6b6c9a13652f8e7329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a01b1aef3e2c5b729472bc9eaa82541f9" name="a01b1aef3e2c5b729472bc9eaa82541f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b1aef3e2c5b729472bc9eaa82541f9">&#9670;&nbsp;</a></span>FibonacciHeap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FibonacciHeap::FibonacciHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 Constructor to create a Fibonacci Heap with one node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>single node to insert to the newly created Fibonacci Heap</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a389dff05276dc7cd14c12838715236c6" name="a389dff05276dc7cd14c12838715236c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389dff05276dc7cd14c12838715236c6">&#9670;&nbsp;</a></span>cascadingCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FibonacciHeap::cascadingCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 This operation is used by decreaseKey(). It cuts y from its parent and makes it a new root, however the parent of y is the new y. It calls itself recursivly, to cut all children of node n and make them new roots. It recurses until y is a root or it finds an unmarked node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td><a class="el" href="../../dc/d8f/class_node.html">Node</a> y, which we want to cut from its parent parent[y]</td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">CASCADING-CUT(H, y)</div>
<div class="line"> 1 z ← p[y]</div>
<div class="line"> 2 <span class="keywordflow">if</span> z ≠ NIL </div>
<div class="line"> 3    then <span class="keywordflow">if</span> mark[y] = FALSE</div>
<div class="line"> 4            then mark[y] ← TRUE</div>
<div class="line"> 5            <span class="keywordflow">else</span> CUT(H, y, z)</div>
<div class="line"> 6                 CASCADING-CUT(H, z)</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a15e16b4de472d878d59d5beccbc84e79" name="a15e16b4de472d878d59d5beccbc84e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e16b4de472d878d59d5beccbc84e79">&#9670;&nbsp;</a></span>consolidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FibonacciHeap::consolidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 This operation is used by extractMin(). It is used to link roots that has equal degrees until each root in the rool List of H, has a unique degree. </p>
<p ><b>Pseudocode </b> </p><div class="fragment"><div class="line">CONSOLIDATE(H)</div>
<div class="line">  1 <span class="keywordflow">for</span> i ← 0 to D(n[H])     <span class="comment">//D(n[H]) Maximum degree of any node in Heap H</span></div>
<div class="line">  2      <span class="keywordflow">do</span> A[i] ← NIL       <span class="comment">//A[] buffer we want to use to link the trees together</span></div>
<div class="line">  3 <span class="keywordflow">for each</span> node w in the <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list of H</div>
<div class="line">  4      <span class="keywordflow">do</span> x ← w</div>
<div class="line">  5         d ← degree[x]</div>
<div class="line">  6         <span class="keywordflow">while</span> A[d] ≠ NIL</div>
<div class="line">  7             <span class="keywordflow">do</span> y ← A[d]      ▹ Another node with the same degree as x.</div>
<div class="line">  8                <span class="keywordflow">if</span> key[x] &gt; key[y]</div>
<div class="line">  9                   then exchange x ↔ y</div>
<div class="line"> 10                FIB-HEAP-LINK(H, y, x)</div>
<div class="line"> 11                A[d] ← NIL</div>
<div class="line"> 12                d←d + 1</div>
<div class="line"> 13         A[d] ←x</div>
<div class="line"> 14 <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] ← NIL</div>
<div class="line"> 15 <span class="keywordflow">for</span> i← 0 to D(n[H])</div>
<div class="line"> 16      <span class="keywordflow">do</span> <span class="keywordflow">if</span> A[i] ≠ NIL</div>
<div class="line"> 17            then add A[i] to the <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list of H</div>
<div class="line"> 18                 <span class="keywordflow">if</span> <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] = NIL or key[A[i]] &lt; key[<a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H]]</div>
<div class="line"> 19                    then <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] ←A[i]</div>
<div class="ttc" id="aclass_fibonacci_heap_html_a64dd6968ecec33c55c92161f1cea337f"><div class="ttname"><a href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">FibonacciHeap::root</a></div><div class="ttdeci">Node * root</div><div class="ttdoc">pointer to the root in Heap H</div><div class="ttdef"><b>Definition:</b> FibonacciHeap.hpp:156</div></div>
<div class="ttc" id="aclass_fibonacci_heap_html_ad53e7b074024d6b6c9a13652f8e7329b"><div class="ttname"><a href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">FibonacciHeap::min</a></div><div class="ttdeci">Node * min</div><div class="ttdoc">pointer the Node with the minimum key value</div><div class="ttdef"><b>Definition:</b> FibonacciHeap.hpp:160</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2642da134c9235d5b4a0c5ac005c055e" name="a2642da134c9235d5b4a0c5ac005c055e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2642da134c9235d5b4a0c5ac005c055e">&#9670;&nbsp;</a></span>cut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FibonacciHeap::cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 This operation is used by decreaseKey(). it is used to cut the link between node x and its parent y making x a new root in the root list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="../../dc/d8f/class_node.html">Node</a> x, which we want to cut from its parent y</td></tr>
    <tr><td class="paramname">y</td><td><a class="el" href="../../dc/d8f/class_node.html">Node</a> y, parent of x</td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">CUT(H, x, y)</div>
<div class="line"> 1 remove x from the child list of y, decrementing degree[y]</div>
<div class="line"> 2 add x to the <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list of H</div>
<div class="line"> 3 parent[x] ← NIL 4 mark[x] ← FALSE</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3073baeb16636d2f607a88340e6f0823" name="a3073baeb16636d2f607a88340e6f0823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3073baeb16636d2f607a88340e6f0823">&#9670;&nbsp;</a></span>FibonacciHeap_decreaseKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FibonacciHeap::FibonacciHeap_decreaseKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 Operation used to decrease a key k of a node x. It has O(c) actual cost, and O(1) amortized cost </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node, whose key we want to decrease</td></tr>
    <tr><td class="paramname">k</td><td>New key k that we want to assign to node</td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">FIB-HEAP-DECREASE-KEY(H, x, k)</div>
<div class="line"> 1  <span class="keywordflow">if</span> k &gt; key[x]</div>
<div class="line"> 2     then error <span class="stringliteral">&quot;new key is greater than current key&quot;</span></div>
<div class="line"> 3  key[x] ← k</div>
<div class="line"> 4  y ← parent[x]</div>
<div class="line"> 5  <span class="keywordflow">if</span> y≠ NIL and key[x] &lt; key[y]</div>
<div class="line"> 6     then CUT(H, x, y)            <span class="comment">//CUT() is included in the documentation</span></div>
<div class="line"> 7          CASCADING-CUT(H, y)     <span class="comment">//CASCADING-CUT() is included in the documentation</span></div>
<div class="line"> 8  <span class="keywordflow">if</span> key[x] &lt; key[<a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H]]</div>
<div class="line"> 9      then <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] ←x</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4d7ed8f7289a45623bcd296c8ae5ce53" name="a4d7ed8f7289a45623bcd296c8ae5ce53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7ed8f7289a45623bcd296c8ae5ce53">&#9670;&nbsp;</a></span>FibonacciHeap_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FibonacciHeap::FibonacciHeap_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 This operation is used to delete a node n from Heap. Its amortized cost is O(lg n) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="../../dc/d8f/class_node.html">Node</a> n, which we want to delete from H</td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">FIB-HEAP-DELETE(H, x)</div>
<div class="line"> 1 FIB-HEAP-DECREASE-KEY(H, x, -∞)</div>
<div class="line"> 2 FIB-HEAP-EXTRACT-MIN(H) </div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1e711c7230240cebd272eed18becfd13" name="a1e711c7230240cebd272eed18becfd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e711c7230240cebd272eed18becfd13">&#9670;&nbsp;</a></span>FibonacciHeap_extractMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d8f/class_node.html">Node</a> * FibonacciHeap::FibonacciHeap_extractMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 Operation used to extract the node with the highest priority (node with minimum key), the operation removes it from the Heap and returns it. It has O(D(n) + t(H)) actual cost, and O(D(n)) amortized cost which is O(lg n) </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dc/d8f/class_node.html">Node</a> x with the minimum key (node with highest priority) </dd></dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">FIB-HEAP-EXTRACT-MIN(H)</div>
<div class="line">  1  z←min[H]</div>
<div class="line">  2  <span class="keywordflow">if</span> z≠ NIL</div>
<div class="line">  3     then <span class="keywordflow">for each</span> child x of z</div>
<div class="line">  4              <span class="keywordflow">do</span> add x to the <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list of H</div>
<div class="line">  5                 parent[x] ← NIL</div>
<div class="line">  6          remove z from the <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list of H</div>
<div class="line">  7          <span class="keywordflow">if</span> z = right[z]</div>
<div class="line">  8             then <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] ← NIL</div>
<div class="line">  9             <span class="keywordflow">else</span> <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] ← right[z]</div>
<div class="line"> 10                  CONSOLIDATE(H)</div>
<div class="line"> 11          n[H] ← n[H] - 1</div>
<div class="line"> 12  <span class="keywordflow">return</span> z</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3805764e424d13b921e1938b068b1c30" name="a3805764e424d13b921e1938b068b1c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3805764e424d13b921e1938b068b1c30">&#9670;&nbsp;</a></span>FibonacciHeap_Insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FibonacciHeap::FibonacciHeap_Insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 Insert Operation to insert a new node n into a Fibonacci Heap H. It has O(1) actual cost and O(1) amortized cost </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="../../dc/d8f/class_node.html">Node</a> to insert into the Fibonacci Heap H </td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">FIB-HEAP-INSERT(H, x)  </div>
<div class="line"> 1  degree[x] ← 0    <span class="comment">//degree of node x</span></div>
<div class="line"> 2  parent[x] ← NIL  <span class="comment">//Parent of node x</span></div>
<div class="line"> 3  child[x] ← NIL   <span class="comment">//Child of node x</span></div>
<div class="line"> 4  left[x] ←x       <span class="comment">//Node left to node x</span></div>
<div class="line"> 5  right[x] ←x      <span class="comment">//Node right to node x</span></div>
<div class="line"> 6  mark[x] ← FALSE  <span class="comment">//Mark of x</span></div>
<div class="line"> 7  concatenate the <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list containing x with <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list H </div>
<div class="line"> 8  <span class="keywordflow">if</span> <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] = NIL or key[x] &lt; key[<a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H]]  </div>
<div class="line"> 9  then <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] ←x 10  n[H] ←n[H] + 1    <span class="comment">//n[H]= number of nodes in H</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5083823697f227b55cc041db6a001788" name="a5083823697f227b55cc041db6a001788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5083823697f227b55cc041db6a001788">&#9670;&nbsp;</a></span>FibonacciHeap_Link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FibonacciHeap::FibonacciHeap_Link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 This operation is used to link nodes together, it does so by removing a node y from the root list of heap H, and making it a child of a node x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The node y, which will be removed from the root list and assigned as a child to node x</td></tr>
    <tr><td class="paramname">x</td><td><a class="el" href="../../dc/d8f/class_node.html">Node</a> x, which will be the parent of y </td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">FIB-HEAP-LINK(H, y, x)</div>
<div class="line"> 1  remove y from the <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list of H</div>
<div class="line"> 2  make y a child of x, incrementing degree[x]</div>
<div class="line"> 3  mark[y] ← FALSE </div>
</div><!-- fragment --> 
</div>
</div>
<a id="ace10cdd22faa2ccf322c15f998e1a87c" name="ace10cdd22faa2ccf322c15f998e1a87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace10cdd22faa2ccf322c15f998e1a87c">&#9670;&nbsp;</a></span>FibonacciHeap_Union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html">FibonacciHeap</a> * FibonacciHeap::FibonacciHeap_Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html">FibonacciHeap</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p ><b>Description </b> <br  />
 Operation to Merge two Fibonacci Heap H1 and H2 into one Fibonacci Heap H. It has O(1) actual cost and O(1) amortized cost </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H2</td><td>A Fibonacci Heap H2 to merge with Fibonacci Heap H1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Heap H which is the result of merging H1 and H2 together </dd></dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">FIB-HEAP-UNION(H1, H2)</div>
<div class="line"> 1  H← MAKE-FIB-HEAP()</div>
<div class="line"> 2  <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] ←min[H1]</div>
<div class="line"> 3  concatenate the <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list of H2 with the <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#a64dd6968ecec33c55c92161f1cea337f">root</a> list of H</div>
<div class="line"> 4  <span class="keywordflow">if</span> (<a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H1] = NIL) or (<a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H2] ≠ NIL and <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H2] &lt; <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H1])</div>
<div class="line"> 5    then <a class="code hl_variable" href="../../d0/d4b/class_fibonacci_heap.html#ad53e7b074024d6b6c9a13652f8e7329b">min</a>[H] ←min[H2]</div>
<div class="line"> 6  n[H] ←n[H1] + n[H2]     <span class="comment">//n[H]= number of nodes in the heap</span></div>
<div class="line"> 7  free the objects H1 and H2</div>
<div class="line"> 8  <span class="keywordflow">return</span> H</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a141474ef627e68752188119c5158eb13" name="a141474ef627e68752188119c5158eb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141474ef627e68752188119c5158eb13">&#9670;&nbsp;</a></span>getMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d8f/class_node.html">Node</a> * FibonacciHeap::getMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 Getter to get the node with the minimum key </p>
<dl class="section return"><dt>Returns</dt><dd>The node that has the minimum key</dd></dl>

</div>
</div>
<a id="a257f38b37fa18411f8aa7f5c6f1acd48" name="a257f38b37fa18411f8aa7f5c6f1acd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257f38b37fa18411f8aa7f5c6f1acd48">&#9670;&nbsp;</a></span>getnumberOfNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FibonacciHeap::getnumberOfNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description </b> <br  />
 Getter to get the number of nodes n[H] </p>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes n in Fibonacci Heap H</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="../../d8/d68/_fibonacci_heap_8hpp_source.html">FibonacciHeap.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d0/d4b/class_fibonacci_heap.html">FibonacciHeap</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
