<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mergable-Heaps: BinomialHeap Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mergable-Heaps
   </div>
   <div id="projectbrief">Effiecent Mergable Heaps</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dc/de9/class_binomial_heap.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../d7/d8a/class_binomial_heap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">BinomialHeap Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ace4f32509eae5e8508433d7e291f2a3e"><td class="memItemLeft" align="right" valign="top"><a id="ace4f32509eae5e8508433d7e291f2a3e" name="ace4f32509eae5e8508433d7e291f2a3e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BinomialHeap</b> ()</td></tr>
<tr class="memdesc:ace4f32509eae5e8508433d7e291f2a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 Default Constructor, used to create a new empty Binomial Heap H. This operation takes O(1) time <br /></td></tr>
<tr class="separator:ace4f32509eae5e8508433d7e291f2a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8779d9906c2760101980e377d8ca15cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de9/class_binomial_heap.html#a8779d9906c2760101980e377d8ca15cf">BinomialHeap_Insert</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *)</td></tr>
<tr class="memdesc:a8779d9906c2760101980e377d8ca15cf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 The BinomialHeap_Insert is used to insert a node n into a binomial heap H This operation has O(lg n) cost  <a href="../../dc/de9/class_binomial_heap.html#a8779d9906c2760101980e377d8ca15cf">More...</a><br /></td></tr>
<tr class="separator:a8779d9906c2760101980e377d8ca15cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2b3e2cd4aaa44caa97dae40ac1ceb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de9/class_binomial_heap.html#afe2b3e2cd4aaa44caa97dae40ac1ceb1">BinomialHeap_Union</a> (<a class="el" href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a> *)</td></tr>
<tr class="memdesc:afe2b3e2cd4aaa44caa97dae40ac1ceb1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 BinomialHeap_Union is used to meld binomial heaps together and keeping the binomial heap priorities It does so by creting a new heap that is the result of using Binomial_Merge(h1,h2); after that it starts linking the trees depending on degree and keys to keep the min-heap property. The result is H= H1 U H2. This operation has O(lg n) cost  <a href="../../dc/de9/class_binomial_heap.html#afe2b3e2cd4aaa44caa97dae40ac1ceb1">More...</a><br /></td></tr>
<tr class="separator:afe2b3e2cd4aaa44caa97dae40ac1ceb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d26eb4927d445aa267a48b2a7dd60db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de9/class_binomial_heap.html#a3d26eb4927d445aa267a48b2a7dd60db">BinomialHeap_extractMin</a> ()</td></tr>
<tr class="memdesc:a3d26eb4927d445aa267a48b2a7dd60db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 BinomialHeap_extractMin is used to return the node n with the minimum key k; it deletes it from the heap H. It reverses the children of the extracted node and puts them inside a new heap H<code> We then call BinomialHeap_Union to meld H and H</code> together. This operation takes O(lg n) time  <a href="../../dc/de9/class_binomial_heap.html#a3d26eb4927d445aa267a48b2a7dd60db">More...</a><br /></td></tr>
<tr class="separator:a3d26eb4927d445aa267a48b2a7dd60db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fe16d9fd232108a677f204b5d5f0cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de9/class_binomial_heap.html#af2fe16d9fd232108a677f204b5d5f0cb">BinomialHeap_decreaseKey</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *, int)</td></tr>
<tr class="memdesc:af2fe16d9fd232108a677f204b5d5f0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 BinomialHeap_decreaseKey is used to decrese a key k of a node n; It checks if the new key k&lsquo; is less than the actual key k of node n then it 'sifts&rsquo; it down; i.e it swaps the node n with its child if it has a child that has key k less than that of node n This operation has O(lg n) cost  <a href="../../dc/de9/class_binomial_heap.html#af2fe16d9fd232108a677f204b5d5f0cb">More...</a><br /></td></tr>
<tr class="separator:af2fe16d9fd232108a677f204b5d5f0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44066fa839c3282aa8d6bce6ed712d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de9/class_binomial_heap.html#aa44066fa839c3282aa8d6bce6ed712d4">BinomialHeap_deleteNode</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *)</td></tr>
<tr class="memdesc:aa44066fa839c3282aa8d6bce6ed712d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 BinomialHeap_deleteNode deletes a node n from heap H; It does so by simply calling BinomialHeap_decreaseKey and make it the node with the minimum key, and then it calls BinomialHeap_extractMin to take it out This Operation takes O(lg n) time  <a href="../../dc/de9/class_binomial_heap.html#aa44066fa839c3282aa8d6bce6ed712d4">More...</a><br /></td></tr>
<tr class="separator:aa44066fa839c3282aa8d6bce6ed712d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab008e77bcb82b2860e96df03737235c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de9/class_binomial_heap.html#ab008e77bcb82b2860e96df03737235c1">BinomialHeap_findMin</a> ()</td></tr>
<tr class="memdesc:ab008e77bcb82b2860e96df03737235c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 <a class="el" href="../../dc/de9/class_binomial_heap.html#ab008e77bcb82b2860e96df03737235c1" title="Description   BinomialHeap_findMin() is used to find the node n with the minimum key k; This Operatio...">BinomialHeap_findMin()</a> is used to find the node n with the minimum key k; This Operation takes O(lg n) time  <a href="../../dc/de9/class_binomial_heap.html#ab008e77bcb82b2860e96df03737235c1">More...</a><br /></td></tr>
<tr class="separator:ab008e77bcb82b2860e96df03737235c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65428f3c6c9d94ef82091d09cf9fd3b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de9/class_binomial_heap.html#a65428f3c6c9d94ef82091d09cf9fd3b1">getRoot</a> ()</td></tr>
<tr class="memdesc:a65428f3c6c9d94ef82091d09cf9fd3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 getter for the root of the heap  <a href="../../dc/de9/class_binomial_heap.html#a65428f3c6c9d94ef82091d09cf9fd3b1">More...</a><br /></td></tr>
<tr class="separator:a65428f3c6c9d94ef82091d09cf9fd3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a254030dd91113955aa454ad148f316e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de9/class_binomial_heap.html#a254030dd91113955aa454ad148f316e2">Binomial_Link</a> (<a class="el" href="../../dc/d8f/class_node.html">Node</a> *, <a class="el" href="../../dc/d8f/class_node.html">Node</a> *)</td></tr>
<tr class="memdesc:a254030dd91113955aa454ad148f316e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 Binomial_Link function is used to link binomial trees of the same degree together; it does so by setting the node with greatest key as a child to the other node. This operation has O(1) runtime complexity  <a href="../../dc/de9/class_binomial_heap.html#a254030dd91113955aa454ad148f316e2">More...</a><br /></td></tr>
<tr class="separator:a254030dd91113955aa454ad148f316e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae135c16850f6393b59df2ff9f15566cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de9/class_binomial_heap.html#ae135c16850f6393b59df2ff9f15566cb">Binomial_Merge</a> (<a class="el" href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a> *, <a class="el" href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a> *)</td></tr>
<tr class="memdesc:ae135c16850f6393b59df2ff9f15566cb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Description</b> <br  />
 Binomial_Merge is used to merge the root lists of two binomial heaps h1 and h2; However it does it without linking the trees together, and it orderes the root list in ascending order, depending on the degree of each node. This operation is executed in O(lg n) time  <a href="../../dc/de9/class_binomial_heap.html#ae135c16850f6393b59df2ff9f15566cb">More...</a><br /></td></tr>
<tr class="separator:ae135c16850f6393b59df2ff9f15566cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab3194ca953cba3ff091ccac1e65d6086"><td class="memItemLeft" align="right" valign="top"><a id="ab3194ca953cba3ff091ccac1e65d6086" name="ab3194ca953cba3ff091ccac1e65d6086"></a>
<a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b></td></tr>
<tr class="memdesc:ab3194ca953cba3ff091ccac1e65d6086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the Root of the heap <br /></td></tr>
<tr class="separator:ab3194ca953cba3ff091ccac1e65d6086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc266fb16191ab383ccefe86fdf9b7a0"><td class="memItemLeft" align="right" valign="top"><a id="afc266fb16191ab383ccefe86fdf9b7a0" name="afc266fb16191ab383ccefe86fdf9b7a0"></a>
<a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>min</b></td></tr>
<tr class="memdesc:afc266fb16191ab383ccefe86fdf9b7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the Minimum <a class="el" href="../../dc/d8f/class_node.html">Node</a> in the heap; this is not necessary to define as we can use findMin <br /></td></tr>
<tr class="separator:afc266fb16191ab383ccefe86fdf9b7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a254030dd91113955aa454ad148f316e2" name="a254030dd91113955aa454ad148f316e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254030dd91113955aa454ad148f316e2">&#9670;&nbsp;</a></span>Binomial_Link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BinomialHeap::Binomial_Link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 Binomial_Link function is used to link binomial trees of the same degree together; it does so by setting the node with greatest key as a child to the other node. This operation has O(1) runtime complexity </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">1st Node</td><td>The node with greatest Key</td></tr>
    <tr><td class="paramname">2nd Node</td><td>The node with least Key</td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">BINOMIAL-LINK(y, z)</div>
<div class="line"> 1  p[y] ← z</div>
<div class="line"> 2  sibling[y] ← child[z]</div>
<div class="line"> 3  child[z] ← y</div>
<div class="line"> 4  degree[z] ← degree[z] + 1</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae135c16850f6393b59df2ff9f15566cb" name="ae135c16850f6393b59df2ff9f15566cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae135c16850f6393b59df2ff9f15566cb">&#9670;&nbsp;</a></span>Binomial_Merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d8f/class_node.html">Node</a> * BinomialHeap::Binomial_Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 Binomial_Merge is used to merge the root lists of two binomial heaps h1 and h2; However it does it without linking the trees together, and it orderes the root list in ascending order, depending on the degree of each node. This operation is executed in O(lg n) time </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">1st Heap</td><td>the first Binomial Heap</td></tr>
    <tr><td class="paramname">2nd Heap</td><td>the second Binomial Heap</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Heap with root list that is the result of merging the root lists of two Binomial Heaps H1 and H2</dd></dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">BINOMIAL-Merge(H, H`)</div>
<div class="line"> 1  a = head[H1]</div>
<div class="line"> 2  b = head[H2]</div>
<div class="line"> 3  head[H1] = Min - Degree(a, b)</div>
<div class="line"> 4  <span class="keywordflow">if</span> head[H1] = NIL</div>
<div class="line"> 5      <span class="keywordflow">return</span></div>
<div class="line"> 6  <span class="keywordflow">if</span> head[H1] = b</div>
<div class="line"> 7      then b = a</div>
<div class="line"> 8  a = head[H1]</div>
<div class="line"> 9  <span class="keywordflow">while</span> b &lt;&gt; NIL</div>
<div class="line">10      <span class="keywordflow">do</span> <span class="keywordflow">if</span> sibling[a] = NIL</div>
<div class="line">11          then sibling[a] = b</div>
<div class="line">12              <span class="keywordflow">return</span></div>
<div class="line">13      <span class="keywordflow">else</span> <span class="keywordflow">if</span> degree[sibling[a]] &lt; degree[b]</div>
<div class="line">14              then a = sibling[a]</div>
<div class="line">15      <span class="keywordflow">else</span> c = sibling[b]</div>
<div class="line">16              sibling[b] = sibling[a]</div>
<div class="line">17              sibling[a] = b</div>
<div class="line">18              a = sibling[a]</div>
<div class="line">19              b = c </div>
</div><!-- fragment --> 
</div>
</div>
<a id="af2fe16d9fd232108a677f204b5d5f0cb" name="af2fe16d9fd232108a677f204b5d5f0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fe16d9fd232108a677f204b5d5f0cb">&#9670;&nbsp;</a></span>BinomialHeap_decreaseKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinomialHeap::BinomialHeap_decreaseKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 BinomialHeap_decreaseKey is used to decrese a key k of a node n; It checks if the new key k&lsquo; is less than the actual key k of node n then it 'sifts&rsquo; it down; i.e it swaps the node n with its child if it has a child that has key k less than that of node n This operation has O(lg n) cost </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="../../dc/d8f/class_node.html">Node</a> n, whose key we want to decrese</td></tr>
    <tr><td class="paramname">k</td><td>new key that we want to assign to node n</td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">BINOMIAL-HEAP-DECREASE-KEY(H, x, k)</div>
<div class="line">  1 <span class="keywordflow">if</span> k &gt; key[x]</div>
<div class="line">  2    then error <span class="stringliteral">&quot;new key is greater than current key&quot;</span></div>
<div class="line">  3 key[x] ← k</div>
<div class="line">  4 y ← x</div>
<div class="line">  5 z ← p[y]</div>
<div class="line">  6 <span class="keywordflow">while</span> z≠ NIL and key[y] &lt; key[z]</div>
<div class="line">  7     <span class="keywordflow">do</span> exchange key[y] ↔ key[z]</div>
<div class="line">  8        ▸ If y and z have satellite fields, exchange them, too.</div>
<div class="line">  9        y ← z</div>
<div class="line"> 10        z ← p[y]</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa44066fa839c3282aa8d6bce6ed712d4" name="aa44066fa839c3282aa8d6bce6ed712d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44066fa839c3282aa8d6bce6ed712d4">&#9670;&nbsp;</a></span>BinomialHeap_deleteNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinomialHeap::BinomialHeap_deleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 BinomialHeap_deleteNode deletes a node n from heap H; It does so by simply calling BinomialHeap_decreaseKey and make it the node with the minimum key, and then it calls BinomialHeap_extractMin to take it out This Operation takes O(lg n) time </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="../../dc/d8f/class_node.html">Node</a> to be deleted</td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">BINOMIAL-HEAP-DELETE(H, x)</div>
<div class="line"> 1  BINOMIAL-HEAP-DECREASE-KEY(H, x, -∞)</div>
<div class="line"> 2  BINOMIAL-HEAP-EXTRACT-MIN(H)</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3d26eb4927d445aa267a48b2a7dd60db" name="a3d26eb4927d445aa267a48b2a7dd60db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d26eb4927d445aa267a48b2a7dd60db">&#9670;&nbsp;</a></span>BinomialHeap_extractMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d8f/class_node.html">Node</a> * BinomialHeap::BinomialHeap_extractMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 BinomialHeap_extractMin is used to return the node n with the minimum key k; it deletes it from the heap H. It reverses the children of the extracted node and puts them inside a new heap H<code> We then call BinomialHeap_Union to meld H and H</code> together. This operation takes O(lg n) time </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="../../dc/d8f/class_node.html">Node</a> n with the minimum Key k </dd></dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">BINOMIAL-HEAP-EXTRACT-MIN(H)</div>
<div class="line"> 1  find the <a class="code hl_variable" href="../../dc/de9/class_binomial_heap.html#ab3194ca953cba3ff091ccac1e65d6086">root</a> x with the minimum key in the <a class="code hl_variable" href="../../dc/de9/class_binomial_heap.html#ab3194ca953cba3ff091ccac1e65d6086">root</a> list of H, and remove x from the <a class="code hl_variable" href="../../dc/de9/class_binomial_heap.html#ab3194ca953cba3ff091ccac1e65d6086">root</a> list of H @see <a class="code hl_function" href="../../dc/de9/class_binomial_heap.html#ab008e77bcb82b2860e96df03737235c1">BinomialHeap_findMin</a>()</div>
<div class="line"> 2  H′ ← MAKE-BINOMIAL-HEAP()</div>
<div class="line"> 3  reverse the order of the linked list of x<span class="stringliteral">&#39;s children, and set head[H′] to point to the head of the resulting list</span></div>
<div class="line"><span class="stringliteral"> 4  H ← BINOMIAL-HEAP-UNION(H, H′)</span></div>
<div class="line"><span class="stringliteral"> 5  return x</span></div>
<div class="ttc" id="aclass_binomial_heap_html_ab008e77bcb82b2860e96df03737235c1"><div class="ttname"><a href="../../dc/de9/class_binomial_heap.html#ab008e77bcb82b2860e96df03737235c1">BinomialHeap::BinomialHeap_findMin</a></div><div class="ttdeci">Node * BinomialHeap_findMin()</div><div class="ttdoc">Description   BinomialHeap_findMin() is used to find the node n with the minimum key k; This Operatio...</div></div>
<div class="ttc" id="aclass_binomial_heap_html_ab3194ca953cba3ff091ccac1e65d6086"><div class="ttname"><a href="../../dc/de9/class_binomial_heap.html#ab3194ca953cba3ff091ccac1e65d6086">BinomialHeap::root</a></div><div class="ttdeci">Node * root</div><div class="ttdoc">Pointer to the Root of the heap</div><div class="ttdef"><b>Definition:</b> BinomialHeap.hpp:19</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab008e77bcb82b2860e96df03737235c1" name="ab008e77bcb82b2860e96df03737235c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab008e77bcb82b2860e96df03737235c1">&#9670;&nbsp;</a></span>BinomialHeap_findMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d8f/class_node.html">Node</a> * BinomialHeap::BinomialHeap_findMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 <a class="el" href="../../dc/de9/class_binomial_heap.html#ab008e77bcb82b2860e96df03737235c1" title="Description   BinomialHeap_findMin() is used to find the node n with the minimum key k; This Operatio...">BinomialHeap_findMin()</a> is used to find the node n with the minimum key k; This Operation takes O(lg n) time </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="../../dc/d8f/class_node.html">Node</a> n with the minimum Key k</dd></dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">BINOMIAL-HEAP-MINIMUM(H)</div>
<div class="line"> 1  y ← NIL</div>
<div class="line"> 2  x ← head[H]</div>
<div class="line"> 3  <a class="code hl_variable" href="../../dc/de9/class_binomial_heap.html#afc266fb16191ab383ccefe86fdf9b7a0">min</a> ← ∞</div>
<div class="line"> 4  <span class="keywordflow">while</span> x ≠ NIL</div>
<div class="line"> 5     <span class="keywordflow">do</span> <span class="keywordflow">if</span> key[x] &lt; <a class="code hl_variable" href="../../dc/de9/class_binomial_heap.html#afc266fb16191ab383ccefe86fdf9b7a0">min</a></div>
<div class="line"> 6           then <a class="code hl_variable" href="../../dc/de9/class_binomial_heap.html#afc266fb16191ab383ccefe86fdf9b7a0">min</a> ← key[x]</div>
<div class="line"> 7                y ← x </div>
<div class="line"> 8         x ← sibling[x]</div>
<div class="line"> 9  <span class="keywordflow">return</span> y</div>
<div class="ttc" id="aclass_binomial_heap_html_afc266fb16191ab383ccefe86fdf9b7a0"><div class="ttname"><a href="../../dc/de9/class_binomial_heap.html#afc266fb16191ab383ccefe86fdf9b7a0">BinomialHeap::min</a></div><div class="ttdeci">Node * min</div><div class="ttdoc">Pointer to the Minimum Node in the heap; this is not necessary to define as we can use findMin</div><div class="ttdef"><b>Definition:</b> BinomialHeap.hpp:23</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8779d9906c2760101980e377d8ca15cf" name="a8779d9906c2760101980e377d8ca15cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8779d9906c2760101980e377d8ca15cf">&#9670;&nbsp;</a></span>BinomialHeap_Insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinomialHeap::BinomialHeap_Insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d8f/class_node.html">Node</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 The BinomialHeap_Insert is used to insert a node n into a binomial heap H This operation has O(lg n) cost </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="../../dc/d8f/class_node.html">Node</a> to be inserted </td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">BINOMIAL-HEAP-INSERT(H, x)</div>
<div class="line"> 1  H′← MAKE-BINOMIAL-HEAP()    <span class="comment">//create a new Binomial Heap</span></div>
<div class="line"> 2  p[x] ← NIL                  <span class="comment">//p[x] is the parent of x</span></div>
<div class="line"> 3  child[x] ← NIL              <span class="comment">//child[x] is the child of x</span></div>
<div class="line"> 4  sibling[x] ← NIL</div>
<div class="line"> 5  degree[x] ← 0</div>
<div class="line"> 6  head[H′] ← x</div>
<div class="line"> 7  H← BINOMIAL-HEAP-UNION(H, H′) </div>
</div><!-- fragment --> 
</div>
</div>
<a id="afe2b3e2cd4aaa44caa97dae40ac1ceb1" name="afe2b3e2cd4aaa44caa97dae40ac1ceb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2b3e2cd4aaa44caa97dae40ac1ceb1">&#9670;&nbsp;</a></span>BinomialHeap_Union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BinomialHeap::BinomialHeap_Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 BinomialHeap_Union is used to meld binomial heaps together and keeping the binomial heap priorities It does so by creting a new heap that is the result of using Binomial_Merge(h1,h2); after that it starts linking the trees depending on degree and keys to keep the min-heap property. The result is H= H1 U H2. This operation has O(lg n) cost </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Heap</td><td>A binomial Heap to meld with the current heap</td></tr>
  </table>
  </dd>
</dl>
<p><b>Pseudocode </b> </p><div class="fragment"><div class="line">BINOMIAL-HEAP-UNION(H1, H2)</div>
<div class="line"> 1  H ← MAKE-BINOMIAL-HEAP()</div>
<div class="line"> 2  head[H] ← BINOMIAL-HEAP-MERGE(H1, H2)       @see <a class="code hl_function" href="../../dc/de9/class_binomial_heap.html#ae135c16850f6393b59df2ff9f15566cb">Binomial_Merge</a>(<a class="code hl_class" href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a>*, <a class="code hl_class" href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a>*)</div>
<div class="line"> 3  free the objects H1 and H2 but not the lists they point to </div>
<div class="line"> 4  <span class="keywordflow">if</span> head[H] = NIL</div>
<div class="line"> 5     then <span class="keywordflow">return</span> H </div>
<div class="line"> 6  prev-x ← NIL </div>
<div class="line"> 7  x ← head[H]</div>
<div class="line"> 8  next-x ← sibling[x]</div>
<div class="line"> 9  <span class="keywordflow">while</span> next-x ≠ NIL</div>
<div class="line">10      <span class="keywordflow">do</span> <span class="keywordflow">if</span> (degree[x] ≠ degree[next-x]) or (sibling[next-x] ≠ NIL and degree[sibling[next-x]] = degree[x])</div>
<div class="line">11            then prev-x ← x </div>
<div class="line">12                 x ← next-x </div>
<div class="line">13            <span class="keywordflow">else</span> <span class="keywordflow">if</span> key[x] ≤ key[next-x]</div>
<div class="line">14                    then sibling[x] ← sibling[next-x]          </div>
<div class="line">15                         BINOMIAL-LINK(next-x, x)    @see <a class="code hl_function" href="../../dc/de9/class_binomial_heap.html#a254030dd91113955aa454ad148f316e2">Binomial_Link</a>(<a class="code hl_class" href="../../dc/d8f/class_node.html">Node</a>*,<a class="code hl_class" href="../../dc/d8f/class_node.html">Node</a>*);          </div>
<div class="line">16                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> prev-x = NIL                        </div>
<div class="line">17                            then head[H] ←next-x▹ Case 4</div>
<div class="line">18                            <span class="keywordflow">else</span> sibling[prev-x] ← next-x</div>
<div class="line">19                         BINOMIAL-LINK(x, next-x)               </div>
<div class="line">20                         x ← next-x</div>
<div class="line">21         next-x ← sibling[x]</div>
<div class="line">22  <span class="keywordflow">return</span> H</div>
<div class="ttc" id="aclass_binomial_heap_html"><div class="ttname"><a href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a></div><div class="ttdef"><b>Definition:</b> BinomialHeap.hpp:14</div></div>
<div class="ttc" id="aclass_binomial_heap_html_a254030dd91113955aa454ad148f316e2"><div class="ttname"><a href="../../dc/de9/class_binomial_heap.html#a254030dd91113955aa454ad148f316e2">BinomialHeap::Binomial_Link</a></div><div class="ttdeci">void Binomial_Link(Node *, Node *)</div><div class="ttdoc">Description   Binomial_Link function is used to link binomial trees of the same degree together; it d...</div></div>
<div class="ttc" id="aclass_binomial_heap_html_ae135c16850f6393b59df2ff9f15566cb"><div class="ttname"><a href="../../dc/de9/class_binomial_heap.html#ae135c16850f6393b59df2ff9f15566cb">BinomialHeap::Binomial_Merge</a></div><div class="ttdeci">Node * Binomial_Merge(BinomialHeap *, BinomialHeap *)</div><div class="ttdoc">Description   Binomial_Merge is used to merge the root lists of two binomial heaps h1 and h2; However...</div></div>
<div class="ttc" id="aclass_node_html"><div class="ttname"><a href="../../dc/d8f/class_node.html">Node</a></div><div class="ttdef"><b>Definition:</b> node.hpp:13</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a65428f3c6c9d94ef82091d09cf9fd3b1" name="a65428f3c6c9d94ef82091d09cf9fd3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65428f3c6c9d94ef82091d09cf9fd3b1">&#9670;&nbsp;</a></span>getRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d8f/class_node.html">Node</a> * BinomialHeap::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Description</b> <br  />
 getter for the root of the heap </p>
<dl class="section return"><dt>Returns</dt><dd>Root r of Heap H </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="../../d7/d09/_binomial_heap_8hpp_source.html">BinomialHeap.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dc/de9/class_binomial_heap.html">BinomialHeap</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
